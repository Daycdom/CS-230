# CS-230
  For this project I was asked to work as a Consultant for The Gaming Room. The Gaming Room wants to expand development to server multiple platforms of the already existing game, Draw It or Lose It. They would like to expand via web-development. The game is multiplayer where multiple clients connect to a single game, and there are multiple games running at simultaneously. The concept of the game is that a application renders images from a library of stock drawings, which act as clues. Each game consist of four round, each lasting one minute. The user guesses on a puzzle, such as a title, thing, phrase, or even a singular word. The images steadily render in, and fully render at 30 seconds. If the team guessing does not guess correctly, the other teams have an opportunity to make one guess each over a 15 second period.
 
  The project was a bit confusing at first, but that was mainly my own fault due to feeling a bit of burnout and not being able to put in full effort. As for what I feel I did the best, it would have to be the evaluation and domain model. I feel like I could've improved the final part, but I was having some difficulty with the recommendations due to a lack of familiarity. I would improve it by improving my familiarity with Linux, as well as expanding my knowledge of Linux, as I recommended Linux. The domain model is definitely the most helpful part of the project when developing the code, as it sets out a clear order of organization as well as a reference to go back to when necessary. 

  When developing software for a client, understanding the needs of the client is extremely important, as it allows you to develop the software exactly as needed. The client may have less knowledge regarding the software you develop for them, so you may need to fill in the gaps according to the clients needs. The client is the receiver of the product you develop, so if it is not up to their requirements and needs, you would have to review your own understanding of the clients needs which could be time consuming and cause a loss of efficiency. When designing the software, approaching it piece by piece and making it into smaller pieces was a good method to keep up understanding and not spreading myself too thin. I would continue this in the future, and continue to break up the steps to the best of my ability.
